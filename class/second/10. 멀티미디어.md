# 10. 멀티미디어

앱에서 카메라를 제어하기 위해서는 Camera API를 이용해야 한다. 이외에도 Camera2 API를 이용하는 방식이 있다. 최근에 나온 Camera2 API를 활용하면 카메라를 더 세밀하게 제어할 수 있지만 하위 호환성의 문제가 남아 있다.

앱에서 카메라를 이용하려면 퍼미션이 필요하다. 카메라에 관련된 퍼미션은 android.permission.CAMERA 이다.

```mxl
<uses-permission android:name="android.permission.CAMERA"/>
```

카메에서 넘어오는 영상을 화면에 출력하기 위해서 TextureView를 사용한다. 레이아웃 XML 파일에 카메리 영상을 출력할 TextureView를 준비한다.

```xml
<TextureView
    android:id="@+id/textureV_show"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintHorizontal_bias="0.5"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent" />
```

이후에는 TextureView.SurfaceTextureListener를 Activity에 구현하고 다음 함수들을 추가해 주자.

onSurfaceTextureAvailable()

onSurfaceTextureSizeChanged()

onSurfaceTextrueDestroyed()

onSurfaceTextureUpdated()

```java
package rj.camera;

import android.graphics.SurfaceTexture;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.TextureView;

public class MainActivity extends AppCompatActivity implements TextureView.SurfaceTextureListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    @Override
    public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int i, int i1) {
        
    }

    @Override
    public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture, int i, int i1) {

    }

    @Override
    public boolean onSurfaceTextureDestroyed(SurfaceTexture surfaceTexture) {
        return false;
    }

    @Override
    public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {

    }
}
```



- 주요 함수

  Camera.open() 함수는 카메라를 점유하고 Camera 객체를 생성하는 역할을 한다.  반면에 카메라 작어이 필요 없는 경우에는 Camera.release() 함수를 활용하여 카메라 점유를 해제하는 것이 필요하다. open()함수로 카메라를 점유하면 release() 함수로 해제되기 전까지는 다른앱에서 카메라를 사용할 수 없으니 주의해야 한다.

  ```java
  camera.open();
  camera.release();
  ```

  카메라 작업을 수행하기 전에 카메라 설정 작업을 수행할 수 있다. 설정작업은 Camera.Parameters 객체를 이용하여 Camera 객체의 getParamesters 함수로 얻어 이용할 수 있다. 얻은 Parameters 객체의 다양한 setter 함수를 호출하여 카메라를 설정하게 된다.

  다음은 카메라 영상의 크기를 지정하는 설정이다.

  ```java
  supportedPreviewSizes = parameters.getSupportedPreviewSizes();
  
  if(supportedPreviewSizes != null) {
      previewSize = CameraUtil.getOptimalPreviewSize(supportedPreviewSizes,i, i1);
      parameters.setPreviewSize(previewSize.width, previewSize.height);
  }
  ```

  Preview 크기는 개발자가 임의로 지정할 수 없으며, 스마트폰에서 지원하는 크기 목록을 parameters.getSupportedPreviewSizes()함수로 얻어 지정해야 한다.  여기서는 별도의 CameraUtil 클래스의 getOptimalPreiewSize() 함수로 너비와 높이를 정하고 있다.



  다음 코드로 logcat에서 스마트폰에서 지원하는 크기 목록을 확인할 수 있다.

  ```java
  for(int i2 = 0; i2 < supportedPreviewSizes.size(); i2++) {
  	Log.d("Preview_Size","PrevieSize width:" + String.valueOf(supportedPreviewSizes.get(i2).width)
                      + " PrevieSize height:" + String.valueOf(supportedPreviewSizes.get(i2).height));
  }
  ```

  나타나는 크기 목록 중 어느 키기의 값을 사용할지는 사용자의 스마트폰 뷰의 크기와 비교하여 어느 값을 적용할지 판단해야 한다. 임의로 값을 지정하면 카메라가 동작하기는 하지만 뷰의 가로 세로 비율과 맞지 않아 봐면이 일그러저 보인다



  다음은 영상의 방향을 설정하는 내용이다,

  ```java
  int result = CameraUtil.setCameraDisplayOrientation(this, 0);
  parameters.setRotation(result);
  camera.setDisplayOrientation(result);
  ```

  parameters.setRotation() 함수를 활용해 사진 촬영시 방향과 화면에 출력하는 출력되는 방향을 setDisplayOrientaion() 함수 설정해야 한다.  여기서는 CameraUtil의 setCameraDisplayOrientation() 함수를 통해 얻은 값을 활용한다.



  다음은 카메라로 사진을 찍는 기능을 제공할 때 계속 포커스를 맞추는 설정이다. 

  ```java
  parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
  ```

  설정한  Paramesters값을 Camera.setParameters()함수에 대입하여 설정된 값에 맞게 카메라를 설정하게 된다

  ```java
  camera.setParameters(parameters);
  ```

  카메라를 이용하기 위한 설정이 완료되었다면 카메라로 부터 넘어오는 영상을 TextureView에 전달해 주어야 한다.

  ```java
  try {
  	camera.setPreviewTexture(surfaceTexture);
  } catch(Exception e) {
  	e.printStackTrace();
  }
  camera.startPreview();
  ```

  onSurfaceTextureAvailable() 함수의 매개변수로 전달되는 SurfaceTexture객체를 Camera의 setPerviewTexture()함수에 대입하여 카메라 영상이 TextureView에 전달되도록 하자. 이후 Camera.setPreview() 객체를 활용하면 영상이 TextureView에 출력된다. 카메라의 시작은 startPreview(), 종료는 stopPreview() 함수를 이용한다.

  ```java
  camera.takePicture(null, null, new Camera.PictureCallback() {
  
      @Override
      public void onPictureTaken(byte[] bytes, Camera camera) {
          try {
  
          }catch(Exception e) {
              e.printStackTrace();
          }
      }
  });
  ```

  카메라 Preview 화면이 출력된 후 사진찍는 기능을 제공하고 싶다면 takePicture() 함수를 이용한다.

  void takePicture(

  ​                   Camera.ShutterCallback shutter, CameraPictureCallback raw, Camera.PictureCallback jpeg)

  takePicture() 함수의 매개변수 중 첫번째는 ShutterCallback을 구현한 클래스 객체이며, ShutterCallback의 onShutter() 함수가 자동으로 호출된다. 개발시에 onShutter() 함수에 사진을 찍으면서 수행할 코드를 작성하면 된다.

  나머지 매개변수들은 PictureCallback을 구현한 객체로 두번째 매개변수는 raw타입의 데이터, 세번째는 jpeg 타입의 데이터가 전달된다. 





- 예제 코드

  - MainActivity.java

    ```java
    public class MainActivity extends AppCompatActivity implements
            TextureView.SurfaceTextureListener {
    
        Camera camera;
        List<Camera.Size> supportedPreviewSizes;
        Camera.Size previewSize;
        Button btn_start;
        boolean bCameraPerm = false;
        TextureView textureV_show;
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
    
            textureV_show = (TextureView)findViewById(R.id.textureV_show);
            textureV_show.setSurfaceTextureListener(this);
    
            btn_start = (Button) findViewById(R.id.btn_start);
            btn_start.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    if(camera != null) {
                        camera.takePicture(null, null, new Camera.PictureCallback() {
    
                            @Override
                            public void onPictureTaken(byte[] bytes, Camera camera) {
                                FileOutputStream fos;
    
                                try {
                                    File dir = new File(Environment.getExternalStorageDirectory().getAbsolutePath()+"/myApp");
                                    if(!dir.exists()) {
                                        dir.mkdir();
                                    }
    
                                    File file = File.createTempFile("IMG-", ".jpg", dir);
                                    if(!file.exists()) {
                                        file.createNewFile();
                                    }
    
                                    fos = new FileOutputStream(file);
                                    fos.write(bytes);
                                    fos.flush();
                                    fos.close();
    
    
    								camera.startPreview();
                                }catch(Exception e) {
                                    e.printStackTrace();
                                }
    
                            }
                        });
                    }
                }
            });
    
            setPermission();
    
        }
    
        @Override
        public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int i, int i1) {
            camera = Camera.open();
            Camera.Parameters parameters = camera.getParameters();
            supportedPreviewSizes = parameters.getSupportedPreviewSizes();
    
            for(int i2 = 0; i2 < supportedPreviewSizes.size(); i2++) {
                Log.d("Preview_Size","PrevieSize width:" + String.valueOf(supportedPreviewSizes.get(i2).width)
                        + " PrevieSize height:" + String.valueOf(supportedPreviewSizes.get(i2).height));
            }
    
            if(supportedPreviewSizes != null) {
                previewSize = CameraUtil.getOptimalPreviewSize(supportedPreviewSizes,i, i1);
                parameters.setPreviewSize(previewSize.width, previewSize.height);
            }
    
            int result = CameraUtil.setCameraDisplayOrientation(this, 0);
            parameters.setRotation(result);
            camera.setDisplayOrientation(result);
    
            parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
            camera.setParameters(parameters);
    
            try {
                camera.setPreviewTexture(surfaceTexture);
            } catch(Exception e) {
                e.printStackTrace();
            }
            camera.startPreview();
        }
    
        @Override
        public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture, int i, int i1) {
    
        }
    
        @Override
        public boolean onSurfaceTextureDestroyed(SurfaceTexture surfaceTexture) {
            camera.stopPreview();
            camera.release();
            return true;
        }
    
        @Override
        public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {
    
        }
    
        private void setPermission() {
            if(ContextCompat.checkSelfPermission(this,
                    Manifest.permission.CAMERA) ==
                    PackageManager.PERMISSION_GRANTED) {
                bCameraPerm = true;
            }
    
    
            if(!bCameraPerm) {
                ActivityCompat.requestPermissions(this,
                        new String[] {
                                Manifest.permission.CAMERA
                        }, 200);
            }
    
    
        }
    
        @Override
        public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
                                               @NonNull int[] grantResults) {
            super.onRequestPermissionsResult(requestCode, permissions, grantResults);
            if(requestCode == 200 && grantResults.length > 0) {
                if(grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    bCameraPerm = true;
                }
            }
        }
    }
    
    ```

  - activity_main.xml

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context=".MainActivity">
    
        <TextureView
            android:id="@+id/textureV_show"
            android:layout_width="0dp"
            android:layout_height="0dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintHorizontal_bias="0.0"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />
    
        <android.support.constraint.Guideline
            android:id="@+id/guideline"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            app:layout_constraintGuide_percent="0.85" />
    
        <Button
            android:id="@+id/btn_start"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:layout_marginTop="8dp"
            android:layout_marginEnd="8dp"
            android:layout_marginBottom="8dp"
            android:text="Button"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="@+id/guideline" />
    </android.support.constraint.ConstraintLayout>
    ```

  - CameraUtil.java

    ```java
    public class CameraUtil {
        public static Camera.Size getOptimalPreviewSize(List<Camera.Size> sizes, int w, int h) {
            final double ASPECT_TOLERANCE = 0.1;
            double targetRatio=(double)h / w;
    
            if (sizes == null) return null;
    
            Camera.Size optimalSize = null;
            double minDiff = Double.MAX_VALUE;
    
            int targetHeight = h;
    
            for (Camera.Size size : sizes) {
                double ratio = (double) size.width / size.height;
                if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue;
                if (Math.abs(size.height - targetHeight) < minDiff) {
                    optimalSize = size;
                    minDiff = Math.abs(size.height - targetHeight);
                }
            }
    
            if (optimalSize == null) {
                minDiff = Double.MAX_VALUE;
                for (Camera.Size size : sizes) {
                    if (Math.abs(size.height - targetHeight) < minDiff) {
                        optimalSize = size;
                        minDiff = Math.abs(size.height - targetHeight);
                    }
                }
            }
            return optimalSize;
        }
    
    
        public static int setCameraDisplayOrientation(Activity activity, int cameraId)
        {
            Camera.CameraInfo info = new Camera.CameraInfo();
            Camera.getCameraInfo(cameraId, info);
            int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
            int degrees = 0;
            switch (rotation)
            {
                case Surface.ROTATION_0:
                    degrees = 0;
                    break;
                case Surface.ROTATION_90:
                    degrees = 90;
                    break;
                case Surface.ROTATION_180:
                    degrees = 180;
                    break;
                case Surface.ROTATION_270:
                    degrees = 270;
                    break;
            }
    
            int result;
            if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT)
            {
                result = (info.orientation + degrees) % 360;
                result = (360 - result) % 360;
            }
            else
            {
                result = (info.orientation - degrees + 360) % 360;
            }
    
            return result;
        }
    }
    
    ```
