# 13. 근거리 통신

## 블루투스 설정

블루투스(Bluetooth)무선 근접 통신 방법으로 스마트폰과 스마트폰 혹은 스마트폰과 마우스 등 블루투스를 지원하는 다양한 기기와의 근접 통신에 이용된다. 

- 블루투스 지원 여부 확인

  블루투스와 관련된 작업은 퍼미션이 필요하다. BLUETOOTH 퍼미션은 페어링 된 기기와 데이터를 송수신하기 위해 필요하며, BLUETOOTH_ADMIN은 블루투스 환경설정을 위해 필요하다.

  ```xml
  <uses-permission android:name="android.permission.BLUETOOTH" />
  <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
  ```

  일단 블루투스와 관련된 작업을 하기전에 앱이 동작하는 디바이스가 블루투스를 지원하는지를 체크해야 한다. 대부분의 스마트폰이 블루투스를 지원하지만 그렇지 않은 경우에 대비하여 블루투스 지원 여부를 판단하자.

  ```java
  BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
  if(bluetoothAdapter == null) {
  	Toast.makeText(getApplicationContext(), "Bluetooth를 지원하지 않음",
  	Toast.LENGTH_SHORT).show();
  } else {
  	Toast.makeText(getApplicationContext(), "Bluetooth를 지원함",
  	Toast.LENGTH_SHORT).show();
  }
  ```


- 블루투스 활성 상태 변경

  블루투스를 지원한다면 블루투스를 활성화하거나 비활성화 해야 한다. 사용자가 직접 활성화 할수 있지만 앱에서도 이를 수행할 수 있다.

  ```java
  // 블루투스의 활성 / 비활성화
  if(!bluetoothAdapter.isEnabled()) {
      Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
      startActivityForResult(intent, 5);
  
  	//bluetoothAdapter.enable();
  } else {
  	//bluetoothAdapter.disable();
  }
  ```

  인텐트에  BluetoothAdapter.ACTION_REQUEST_ENABLE를 지정하여 발생시키면 사용자에게 블루투스 활성 여부를 묻는 대화상자를 띄울 수 있다. 대화상자의 선택결과에 따라 startActivityForResult() 함수에서 별도의 처리를 할 수 있다.

  ```java
  @Override
  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
  	switch(requestCode) {
  		case 5:
  			// 블루투스 활성화
  			if(resultCode == RESULT_OK) {
  				Toast.makeText(getApplicationContext(), "Bluetooth가 활성화 되었습니다.",
  					Toast.LENGTH_SHORT).show();
  			} else if(resultCode == RESULT_CANCELED) {
  				Toast.makeText(getApplicationContext(), "Bluetooth가 활성화 되지 않았습니다.", Toast.LENGTH_SHORT).show();
  			}
  		}
  	}
  }
  ```

   이외에는 BluetoothAdapter의 enable() 혹은 disable() 함수를 호출하여 사용자 확인 없이 바로 블루투스 활성 / 비활성 할 수 있다. 



- 기기 검색 허용

  자신의 스마트폰을 다른 기기에서 검색되게 하려면 블루투스 검색을 허용해 주어야 한다. 검색이 허용된 스마트폰은 다른 기기에서 검색해서 인지할 수 있다.

  ```java
  // 기기 검색 허용
  Intent dIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
  dIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 100);
  startActivity(dIntent);
  ```

  BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE 문자열을 인텐트에 담아 허용할 수 있으며, 추가 데이터로 검색허용 시간을 지정하여 보낼 수 있다. 이때 키 값은 BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION로 지정하고 값은 0~3600초 까지 지정할 수 있다.



- 페어링 기기 검색

  특정 기기와 데이터 통신을 하려면 해당 기기와 페어링하여야 하는데 먼저 페어링된 기기 목록을 가져와야 한다.

  ```java
  // 페어링 기기 검색
  Set<BluetoothDevice> devices = bluetoothAdapter.getBondedDevices();
  if(devices.size() > 0) {
  	Iterator<BluetoothDevice> iter = devices.iterator();
  	while(iter.hasNext()) {
  		BluetoothDevice d = iter.next();
  		
  		Log.d("BLUETOOTH_TEST", "name : " +
          			d.getName() + " addr : " + d.getAddress());
  	}
  }
  ```

  기기 들의 정보는 BluetoothDevice 객체 안에 저장되어 있으며, getName(), getAddress() 함수로 기기의 이름과 MAC 주소를 얻을 수 있다.

  위의 코드에서 앱이 필요한 순간 페어링 된 기기의 목록을 얻을 수 있었다. 사용자의 환결설정에서 특정기기와 페어링 하는 순간 감지해야 할 때 앱을 실행하기 위한 브로드 캐스트 리시버를 작성한다.

  ```xml
  <receiver
  	android:name=".BluetoothReceier"
  	android:enabled="true"
  	android:exported="true">
  	<intent-filter>
  		<action android:name="android.bluetooth.device.action.FOUND"/>
  	</intent-filter>
  </receiver>
  ```

  브로드 캐스트 리시버를 android.bluetooth.device.action.FOUND 문자열로 등록하면 페어링 되는 순간 앱이 자동으로 실행된다.



## 블루투스 통신

- 서버로 등작

  데이터 통신에서 서버는 연결요청을 기다리고 있다가 외부 기기에서 연결 요청이 들어오는 순간 연결을 완성하며, 클라이언트는 서버에 연결 요청을 보낸다.

  먼저, 앱이 블루투스 서버로 동작하게 하는 방법은 BluetoothServerSocket클래스를 활용한다.

  ```java
  UUID MY_UUID = UUID.fromString("00001111-0000-1111-0000-0123456789AB");
  BluetoothServerSocket serverSocket =
        bluetoothAdapter.listenUsingRfcommWithServiceRecord("bluetooth_test", MY_UUID);
  ```

  BluetoothServerSocket 객체는 BluetoothAdapter 객체의 listenUsingRfcommWithServiceRecord() 함수를 활용하여 얻을 수 있다. 첫 매개변수는 서비스 이름으로 앱의 이름이나 임의로 지정할 수 있다. 두번째 매개변수는 UUID(Universally Unique Identifier) 값으로 서버와 클라이언트가 공유하여 연결한다.

  ```java
  BluetoothSocket socket = serverSocket.accept();
  ```

  BluetoothServerSocket의 accept() 함수가 실행되면 클라이언트에서 연결 요청이 오기까지 대기상태가 된다. 그러다 연결 요청이 들어오면 accept() 함수에서 클라이언트와 연결 객체인 BluetoothSocket을 반환하며, 이 객체를 이용하여 데이터를 송수신할 IO 객체를 만든다.



- 클라이언트로 동작

  앱이 블루투스 클라이언트로 동작하게 하는 방법을 알아보자. 서버에게 연결 요청을 하기 전에 BluetoothAdapter의 cancelDiscovery() 함수를 호출한다.

  ```java
  BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
  adapter.cancelDiscovery();
  ```

  기기 검색 작업이 느려서 기기 간 연결이 안될 수 있는 점을 피하기 위해 검색을 잠시 멈추고 안전하게 연결하게 연결하자

  다음은 UUID로 식별되는 서버와 연결을 하기위해 페어링된 기기 정보인 BluetoothDevice의 createRfcommSocketToServerRecode() 함수를 호출하여 BluetoothSocket 객체를 얻고 BluetoothSocket의 connect() 함수를 호출하여 서버와 연결을 시도한다

  ```java
  BluetoothSocket clientSocket = device.createRfcommSocketToServerRecode(MY_UUID);
  clientSocket.connect();
  ```

  연결이 정상으로 이뤄지면 데이터를 송수신하게 된다. 



- 데이터의 송수신

  다음은 문자열을 서버에 전송하는 코드이다. BluetoothSocket의 getOutputStream() 함수를 호출하여 데이터 송신을 위한 객체를 얻어 데이터를 송신한다.

  ```java
  out = clientSocket.getOutputStream();
  out.write("Send Message".getBytes());
  out.flush();
  ```

  다음은 데이터 수신을 위한 코드로 BluetoothSocket의 getInputStream() 함수를 이용해 데이터 수신을 위한 객체를 얻고 read() 함수로 수신된 데이터를 읽는다.

  ```
  byte[] buffer = new byte[1024];
  int bytes;
  in = new BufferedInputStream(clientSocket.getInputStream());
  bytes=in.read(buffer);
  ```
